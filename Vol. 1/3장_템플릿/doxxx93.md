# 3장 템플릿

스프링에 적용된 템플릿 기법을 살펴본다.

## 3.1 다시 보는 초난감 DAO

예외상황에 대한 처리가 미흡한 상황이다.

### 3.1.1 예외처리 기능을 갖춘 DAO

DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드는 반드시 예외처리 기능을 갖춰야 한다.

예외가 발생했을 때도 사용한 리소스를 반환하도록 만들어야 한다.

일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리한다.

책은 jdk6 기준으로 서술되어 있어서 try-with-resources 문법을 사용하지 않았다.

[Java – Try with Resources](https://www.baeldung.com/java-try-with-resources)

## 3.2 변하는 것과 변하지 않는 것

### 3.2.1 JDBC try/catc/finally 코드의 문제점

1장에서와 같은 상황이다.

변하지 않지만 반복적으로 사용되는 코드를 분리해내는 작업이 필요하다.

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

#### 메서드 추출

변하는 부분을 추출하는 경우, 분리시킨 메서드를 다른 곳에서 재사용하지 않는다.

#### 템플릿 메서드 패턴 적용

상속을 통해 기능을 확장해서 사용하는 방법이다.

변하지 않는 부분은 슈퍼클래스에 둔다.

변하는 부분은 추상 메서드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓴다.

하지만 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.

#### 전략 패턴 적용

변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임한다.

#### DI 적용을 위한 클라이언트/컨텍스트 분리

Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 Client가 결정한다.

Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달한다.

#### 마이크로 DI

의존관계 주입(DI)는 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다.

- 의존관계에 있는 두 개의 오브젝트
- 위 관계를 다이나믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너)
- 이를 사용하는 클라이언트(가끔 DI 컨테이너의 책임을 가질 수 있다.)

DI 같아 보이지 않는 코드도 있다.

## 3.3 JDBC 전략 패턴의 최적화

### 3.3.1 전략 클래스의 추가 정보

### 3.3.2 전략과 클라이언트의 동거

- 두가지 문제점
  - DAO 메서드마다 새로운 구현 클래스를 만들어야 한다.
  - 부가적인 정보가 필요한 경우, 오브젝트를 전달 받는 생성자와 인스턴스 변수를 추가해야 한다.

#### 중첩 클래스

다른 클래스 내부에 정의되는 클래스

- 스태틱 클래스: 독립적으로 오브젝트로 만들어질 수 있는 클래스
- 내부 클래스: 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 클래스
  - 멤버 내부 클래스: 멤버 필드처럼 오브젝트 레벨에 정의 되는 클래스
  - 로컬 클래스: 메서드 레벨에 정의되는 클래스
  - 익명 내부 클래스: 이름을 갖지 않는 클래스

#### 익명 내부 클래스

클래스 선언과 오브젝트 생성이 결합된 형태

상속할 클래스나 구현할 인터페이스를 생성자 대신 사용한다.

클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.

jdk6 기준으로 작성되었기 때문에, 이 내용은 람다를 사용하는 것으로 대체될 수 있다.

## 3.4 컨텍스트와 DI

### 3.4.1 JdbcContext의 분리

### 3.4.2 JdbcContext의 특별한 DI

#### 스프링 빈으로 DI

- 왜 인터페이스를 사용하지 않았을까 ?
  - UserDao와 JdbcContext는 강한 응집도를 가지고 있다. 따라서, 다른 구현으로 대체해서 사용할 이유가 없다. 이런 경우엔 굳이 인터페이스로 두지말고 강력한 결합 관계를 허용하면 된다.

- 인터페이스를 사용하진 않았지만 JdbcContext와 UserDao를 DI 구조로 만들어야 할 이유는 무엇일까 ?
  - JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이기 때문이다. (JdbcContext는 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적이다.)
  - JdbcContext가 DI를 통해 다른 빈(DataSource)에 의존하고 있기 때문이다. (DI를 위해서는 둘 다 스프링 빈이어야 한다.)

#### 코드를 이용하는 수동 DI

이렇게 되면 싱글톤으로 만드는 것은 포기하고, DAO마다 JdbcContext 오브젝트를 갖고 있게 한다.

따라서, DataSource를 주입받을 수 없게되므로, UserDao의 setDataSource 메소드에서 주입받게 된다.

##### 두가지 DI 방식의 비교

- 스프링 DI
  - 장점: 의존 관계가 설정파일에 명확하게 드러난다
  - 단점: DI의 근본 원칙(인터페이스 구현)에 부합하지 않는 구체적인 클래스와의 관계가 노출된다.
- 코드를 이용하는 수동 DI
  - 장점: 관계가 외부로 노출되지 않는다.
  - 단점: Context를 싱글톤으로 만들 수 없고, 부가적인 코드가 필요하다

## 3.5 템플릿과 콜백

전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 한다.

> 콜백의 경우 메서드 참조가 가능해진 현재, 메서드가 담긴 오브젝트 전달할 필요가 없어졌으려나..?

### 3.5.1 템플릿/콜백의 동작 원리

DI 방식의 전략 패턴 구조이다.

클라이언트각 템플릿 메서드를 호출하면서 콜백 오브젝트를 전달하는 메서드 레벨의 DI가 일어난다.

### 3.5.2 편리한 콜백의 재활용

변하는 것 : 쿼리

변하지 않는 것 : 그 외 코드

### 3.5.3 템플릿/콜백의 응용

스프링에서 제공하는 jdbc 코드에도 템플릿 콜백 기술이 사용된다.

## 3.6 스프링의 JdbcTemplate

### 테스트 보완

- 네거티브 테스트
  - 긍정적인 결과만 테스트하는 것이 아닌, 예외상황에 대한 테스트를 추가한다.


