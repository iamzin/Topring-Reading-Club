# 스프링 효과적인 학습
스프링이 ==**지지하는 가치**==와 ==**이루고자 하는 목표**==를 먼저 이해해야 한다.

# 스프링이란 무엇인가?
- 자바 기반 애플리케이션 프레임워크
    - 애플리케이션 프레임워크란?
        - **(1)애플리케이션의 바탕이 되는 틀**과 **(2)공통 프로그래밍 모델**, **(3)기술 API**를 제공
        - 스프링을 사용한다는 것은 이 3가지 요소를 적극적으로 활용해 애플리케이션 개발한다는 뜻

- **(1) 애플리케이션의 기본 틀 - 스프링 컨테이너**
    - 스프링은 [스프링 컨테이너], [애플리케이션 컨텍스트]라고 불리는 **스프링 런타임 엔진**을 제공
    - 스프링 컨테이너는 설정정보를 참고해 오브젝트를 생성하고 관리
    - 스프링 컨테이너는 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용
    - 스프링을 사용하려면 먼저 **(a)스프링 컨테이너를 다루는 방법**과 **(b)설정정보를 작성하는 법**을 알아야 한다.

-**(2) 공통 프로그래밍 모델 - IoC/DI, 서비스 추상화, AOP**
- 코드가 어떻게 작성되어야 하는지에 대한 가이드라인 = 프로그래밍 모델. 스프링은 총 3가지의 핵심 프로그래밍 모델을 지원.
- (a) IoC/DI - 오브젝트 생명주기와 의존관계에 대한 프로그래밍 모델
- (b) 서비스 추상화 - 구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 둠. 이식성이 뛰어남
- (c) AOP - 애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델

-**(3) 기술 API**
- 웹 프레젠테이션 계층, 서비스 계층, 도메인 계층, 데이터 액세스 계층에서 사용할 수 있는 API들.

# 스프링의 성공 요인
- 견고하고 건전한 자바 + 엔터프라이즈 개발의 핵심 가치에 충실했기 때문. 스프링을 사용하는 개발자들은 자연스럽게 자바와 엔터프라이즈 개발의 기본에 충실한 베스트 프랙티스를 적용할 수 있고, 이상적인 개발 철학과 프로그래밍 모델을 이해하게 되고, 좋은 개발 습관을 체득하게 됨
- (1) 단순함 Simplicity
    - 스프링은 당시의 표준이었던 EJB를 비판하면서 등장. EJB는 지나치게 복잡했기 때문.
- (2) 유연성 Flexibility

---

# 0. 오브젝트와 의존관계
- 스프링은 자바 기반 기술. 자바는 객체지향 프로그래밍이 가능한 언어
- 객체지향 프로그래밍에서는 **오브젝트**에 많은 관심을 두고 있음
    - 언제 생성되고, 언제 소멸되는가?
    - 누가 생성하는가?
    - 다른 오브젝트와 어떻게 관계 맺는가?
    - 어떻게 설계되어야 하는가? 어떤 단위로 만들어져야 하는가?
- 수많은 시행착오를 거치며 만들어진 베스트 프랙티스, 디자인 패턴, 프로그래밍 모델.
- 스프링은 검증된 베스트 프랙티스를 평범한 개발자도 쉽게 적용할 수 있도록 프레임워크 형태로 제공한다.

# 1. 초난감 DAO
- DAO: Data Access Object. 오브젝트. DB에서 데이터를 조회하거나 조작하는 기능을 전담.
- 자바빈: 다음 2가지 관계를 따라 만들어진 오브젝트
    - 디폴트 생성자: 자바빈은 NoArgsConstructor를 가지고 있어야 한다. 프레임워크에서 [[Java Reflection, 자바 리플렉션]]을 이용해 오브젝트를 생성하기 때문에 필요하다.
    - 프로퍼티: 자바빈이 노출하는 속성.
- DAO를 통해
    - DB 커넥션을 얻고
    - SQL을 담은 `Statement`를 만들고
    - 만들어진 `Statement`를 실행하고
    - 작업 중 생성된 `Connection`, `Statement`, `ResultSet`을 닫아주었다.
- 더 나은 코드는 없을까? 어떻게 하면 더 나은 코드를 작성할 수 있을가?

# 2. DAO의 분리
1. 왜 관심사에 따라 분리해야하는가? -> 쉬운 변경을 위해. 기능 A 추가를 위해, 관련없는 B, C를 건들이지 않아도 됨
2. 커넥션 만들기의 추출하는 리팩토링 -> 커넥션을 만드는 부분만 같은 클래스의 메서드로 분리
3. DB 커넥션 만들기의 독립 -> 템플릿 메소드 패턴과 팩토리 메소드 패턴을 사용해 분리.

# 3. DAO의 확장
1. 클래스의 분리 기준. 변화의 이유와 시기, 주기가 같은가, 다른가?
2. 인터페이스를 도입하면 손쉽게 결합을 느슨하게 만들 수 있다. 이제 어떤 클래스를 사용하는지는 중요하지 않다. 원하는 인터페이스를 구현했는지만 중요해질 뿐이다.
3. 개방-폐쇄 원칙. 사용하는 다른 모듈을 확장하는 것에는 열려 있어야 하고, 기존의 코드에는 변화에 영향을 받지 않고 변경에 닫혀있어야 한다.

# 4. 제어의 역전 (IoC)
1. 오브젝트 팩토리의 이용 -> 오브젝트를 생성하고 사용하는 애플리케이션의 로직 흐름을 오브젝트가 아닌, 이를 사용하는 측에 넘긴다.
2. 제어권의 이전을 통한 제어관계 역전

# 5. 스프링의 IoC
1. 오브젝트 팩토리를 이용한 스프링 IoC -> 스프링은 빈 팩토리(~=애플리케이션 컨텍스트)를 사용해 오브젝트(빈)을 관리한다. 여기에서 관리한다는 뜻은 오브젝트로부터 넘겨받은 제어권을 활용해 오브젝트를 생성하고, 주입하고, 삭제하는 등의 활동을 말한다. 빈 팩토리와 애플리케이션 컨텍스트는 미묘하게 다른 어감을 가진 채로 사용되지만 일단은 중요하지 않으므로 넘어가기로 한다. 애플리케이션 컨텍스트가 조금 더 넓은 의미를 갖는다고 생각하자.


# 6. 싱글톤 레지스트리와 오브젝트 스코프
- 디자인 패턴 중 하나인 싱글톤 패턴은 여러 가지 한계점(상속 어려움, 테스트 어려움, 싱글톤 보장 어려움, 전역 상태를 만들어 위험함)을 가지고 있지만, 스프링은 클래스 설계를 변경하지 않고 싱글톤 패턴을 애플리케이션에 적용할 수 있다. 이는 스프링이 애플리케이션 생성을 제어하고 있기 때문에 가능하다.

# 7. 의존관계 주입 (DI)
- IoC가 매우 폭넓게 사용되는 의미인데 반해, DI는 스프링이 어떻게 IoC 원리를 구현했는지 표현한 것이다. '의존관계 주입'. A가 B에 의존하고 있다는 것은 A가 B의 기능을 사용하고 있다는 것이다. 이때 B는 스프링에 의해 런타임 중 A가 사용할 수 있는 형태로 제공된다(컴파일 타임에 A는 인터페이스만 알고 있을 뿐이다.)

---

# Things I Learned
- 모든 클래스에는 자신을 엔트리 포인트로 설정해 직접 실행가능하게 해주는 스태틱 메소드 main()이 있다. 이를 통해 손쉽게 새로 추가한 클래스의 기능을 테스트해볼 수 있다.
- 
```java
public static void main(String[] args) { // 실행 가능
    ...
}
```