# 1. 오브젝트와 의존 관계

## 1.1 초난감 DAO

---

- DAO(Data Access Object)
  - DB를 이용하여 데이터를 조회 또는 조작하는 기능을 전담하는 오브젝트

- 자바 빈(JavaBean)

- 다음 두 가지 관례를 따라 만들어진 오브젝트
  - 디폴트 생성자
    - 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다.
  - 프로퍼티
    - 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 setter와 getter로 접근할 수 있어야한다.

## 1.2 DAO의 분리

---

### 관심사의 분리(Seperation of Concerns)

- 관심이 같은 것 끼리 하나의 객체 안으로 모으고, 관심이 다른 것은 서로 영향을 주지 않도록 분리하는 것
- 객체를 설계할 때 고려해야되는 것
  - 변화에 어떻게 대비할 것 인가?
  - 가장 좋은 대책 → 변화의 폭을 최소한으로 줄이는 것
- 관심사의 분리가 필요한 이유
  - 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
  - 변화는 한 가지 관심에 대해 일어나지만 작업은 한 곳에 집중되지 않은 경우가 많기 때문에 변경을 최소환으로 하기 위해서 관심이 같은 것 끼리 집중되게 한다.

- 리팩토링(Refactoring)
  - 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
- 팩토리 메소드 패턴(Factory Method Pattern)
  - 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴

## 1.3 DAO의 확장

---

- 전략 패턴(Strategy Pattern)
  - 특정 컨텍스트에서 알고리즘을 별도로 분리하는 설계 방법
  - 자신의 기능 맥락(Context)에서 필요에 따라 변경이 필요한 부분을 인터페이스를 통해 외부로 분리시킨 후 구현체를 통해 상호 교체가 가능하게 만든다.

### 객체지향 설계 원칙(SOLID)

- SOLID는 아래 5가지 원칙의 첫 글자를 따서 만든 단어
  - 단일 책임 원칙(SRP, Single Responsibility Principle)
    - 한 클래스는 하나의 책임만 가져야 한다.
  - 개방 폐쇄 원칙(OCP, Open-Closed Principle)
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 리스코프 치환 원칙(LSP, Liskov Subsitution Principle)
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  - 의존관계 역전 원칙(DIP, Dependency Inversion Principle)
    - 상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다.
    - 하위의 모듈이 상위 모듈에 정의한 추상 타입에 의존 해야한다.

### 높은 응집도와 낮은 결합도(high coherence and low coupling)

- 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 소프트웨어 개발의 고전적인 원리로도 설명 가능하다.

- 응집도(Coherence)
  - 변화가 일어날 때 해당 모듈에서 변하는 부분의 정도
- 결합도(Coupling)
  - 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

## 1.4 제어의 역전(IoC)

---

### 제어관계 역전

- 일반적인 프로그램의 흐름
  - main() 메서드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트 결정한다.
- 제어의 역전
  - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.
  - main() 과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.
  - 프레임워크는 제어의 역전이 적용된 대표적인 기술이다.
    - Spring Framework, Laravel
  - IoC 제어권을 가진 오브젝트를 분리해서 만드는 방법도 좋지만 애플리케이션 전반에 적용하려면 스프링과 같은 IoC 프레임워크의 도움을 편이 좋다.
 
- 프레임워크(Framework)와 라이브러리(Library)
  - 프레임워크와 라이브러리의 차이는 제어 흐름을 누가 쥐고있느냐에 따라 결정된다.
  - 프레임워크
    - 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합
    - 제어의 역전 개념이 적용된 대표 기술, 애플리케이션 코드가 프레임워크에 의해 사용된다.
  - 라이브러리
    - 단순 활용가능한 도구들의 집합
    - 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.

## 1.5 스프링의 IoC

---

### 오브젝트 팩토리를 이용한 스프링 IoC

- 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 부른다.
- 빈의 생성과 관계 설정과 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다. 보통은 이를 확장한 애플리케이션 컨텍스트를 주로 사용한다.

- 스프링 빈(Spring Bean)
  - 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
- 애플리케이션 컨텍스트(Application Context)
  - IoC 방식을 따라 만들어진 일종의 빈 팩토리
  - 별도의 정보를 참고해서 빈 생성, 관계 설정등의 제어 작업을 총괄한다.

### 애프리케이션 컨텍스트의 동작 방식

1. @Configuration이 붙은 클래스를 설정정보로 등록한다.
2. @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만든다.
클라이언트가 getBean() 메서드를 호출하면 빈 목록에서 이름이 있는지 찾는다.
  - 존재하면 빈을 생성하는 메서드를 호출해서 오브젝트를 생성 후 클라이언트에게 전달한다.
- 애플리케이션 컨텍스트를 사용했을 때의 장점
  - 클라이언트는 구체적인 팩토리 클래스를 알 필요 없다.
  - 애플리케이션 컨텍스트는 자동생성, 빈 후처리 등의 다양한 기능을 제공한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

---

- 애플리케이션 컨텍스트로 가져온 오브젝트는 완전히 같은 호출 동일성이 보장된다.

- 오브젝트의 동일성과 동등성
  - 동일성(identity) → 완전히 같은 오브젝트(메모리 주소 동일)
  - 동등성(equality) → 각기 다른 오브젝트가 메모리상에 존재하고, 가지고 있는 값이 같은 것

### 싱글톤 레지스트리 애플리케이션 컨텍스트

- 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.
- 대규모의 엔터프라이즈 서버 환경은 요청마다 오브젝트를 생성하면 과부화가 일어날 수 있음으로 싱글톤의 사용이 권장된다.

- 싱글톤 레지스트리(Singleton registry)
  - 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공
  - 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.

### 싱글톤 패턴의 한계

- private 생성자를 가지고 있기 때문에 상속할 수 없다.
- 테스트하기 힘들다.
  - 만들어지는 방식이 제한적이라 테스트에서 사용될 때 목 오브젝트 등으로 대체하기 힘들다.
- 싱글톤 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

- 싱글톤 패턴(Singleton Pattern)
  - 클래스를 애플리케이션 내에서 인스턴스를 하나만 존재하도록 강제하는 패턴이다.

### 싱글톤 오브젝트의 상태

- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.
- 그렇기에 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.
- 파라미터, 로컬 변수, 리턴 값 등을 이용하면 된다.

### 스프링 빈의 스코프

- 스프링에서 만들어지는 대부분의 빈은 스프링 컨테이너 내에서 한 개의 오브젝트만 만들어지는 싱글톤 스코프를 가진다.

- 빈 스코프(Bean scope)
  - 빈이 생성되고, 존재하고, 적용되는 범위

## 1.7 의존관계 주입(DI)

---

### 제어의 역전과 의존관계 주입

- 의존관계 주입은 다음 세 가지 조건을 충족하는 작업이다.
  - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
    - 드러나려면 인터페이스에만 의존해야 한다.
  - 런타임 시점의 의존관계는 컨테이너, 팩토리와 같은 제 3의 존재가 결정한다.
  - 사용할 오브젝트 레퍼런스를 외부에서 주입받음으로 만들어진다.

- 의존관계 주입, 의존성 주입, 의존 오브젝트 주입?
  - 오브젝트 레퍼런스를 외부로부터 제공받고 의존관계가 만들어지는 것이 핵심이다.
  - 의존관계 주입이라는 번역이 적절

### 런타임 의존관계 설정

- 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 방향성을 부여해줘야 한다.
- 의존한다는 것은? A가 B에 의존한다고 가정, 의존대상 B가 변하면 A에 영향을 미친다는 뜻이다.

### 의존관계 검색과 주입

- 의존관계 검색을 사용해야 하는 경우
  - 테스트 코드에서 오브젝트를 가져와야 할 경우
  - 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용할 때(스프링이 제공하기에 직접 구현할 필요 X)

- 의존관계 검색(Dependency lookup)
  - 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 자신이 필요로하는 의존 오브젝트를 능동적으로 찾는다.
  - 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 결정한다면 IoC라고 할 수 없다.

### 메소드를 이용한 의존관계 주입

- 생성자 주입을 권장한다.
- 세터 주입과, 일반 메소드를 이용한 주입은 별로 권장하지 않는다.