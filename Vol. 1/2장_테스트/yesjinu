## 스프링과 테스트
스프링이 개발자에게 제공하는 가장 중요한 가치는 `객체지향`과 `테스트`다. 현대의 앱은 계속 변하고 복잡해져가기 때문에 이 두 가지 무기를 잘 사용하는 것이 좋다.
1. IoC/DI : 오브젝트의 설계, 생성, 관계, 사용에 관한 기술. 객체지향을 이용해 복잡한 엔터프라이즈 앱을 효과적으로 개발할 수 있게 한다.
2. 테스트 : 만들어진 코드에 확신을, 변화에는 대처할 수 있는 자신감을 준다.

## 수동 테스트의 한계
1장에서는 `public static void main` 메서드를 통해 클래스의 메서드를 직접 실행해보고 확인하는 방식으로 테스트를 진행했다. 하지만 여기에는 2가지 한계가 존재한다.
1. 실행의 번거로움 : 테스트하고자 하는 클래스가 여러 개 되면 어떻게 할 것인가? 일일이 찾아다니며 main 메서드를 실행할 것인지?
2. 확인의 번거로움 : 실행 결과를 정답값과 직접 눈으로 비교해야한다. 비교해야하는 값이 수천 가지가 넘는데 가능할까?

## 테스트 자동화
`JUnit`이라는 테스팅 프레임워크를 사용해 테스트를 진행할 것. 이 프레임워크를 사용하면 수동 테스트의 한계에서 지적했던 테스트를 실행하고 확인하는 과정을 자동화할 수 있다. 프레임워크의 기본 동작 원리는 IoC/DI. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. JUnit 프레임워크가 요구하는 조건은 2가지.
1. 메소드가 public으로 선언되어야
2. 메소드에 `@Test` 어노테이션을 붙여주어야

## 몇 가지 새로 알게 된 사실
### 1) JUnit이 테스트를 수행하는 순서
JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
1. 테스트 클래스에서 @Test가 붙은 public, void, 파라미터 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스 오브젝트를 하나 만든다.
3. @Befor가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

따라서 모든 테스트는 다른 테스트와 격리된 상태로 돌아간다. @Before에서 실행되는 setUp 코드 역시 매 테스트마다 새로 수행되므로 더 정확하게는 BeforeEach와 같은 역할을 한다고 할 수 있다.

### 2) `@Autowired`가 빈을 찾는 순서
`@Autowired`가 붙은 인스턴스 변수가 있으면, 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. 그렇다면 같은 타입의 빈이 2개 이상 있는 경우에는 어떻게 할까? 이럴 때에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.
1. 타입으로 찾고
2. 이름으로 찾고